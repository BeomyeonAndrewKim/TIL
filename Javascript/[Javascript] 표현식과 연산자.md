# 표현식과 연산자

## 1. 표현식

표현식은 값으로 평가될 수 있는 문입니다. 그 결과를 다른 표현식에 결합해서 다른 값을 얻을 수 있습니다. 그 값을 또 다른 표현식에 결합해서 또 다른 값을 얻는 식으로 이어질 수 있습니다. 표현식이 아닌 문은 이런 식으로 결합할 수 없습니다.

표현식은 값이 되므로 할당에 쓸 수 있습니다. 즉, 표현식의 결과를 변수나 상수, 프로퍼티에 할당할 수 있습니다.

할당도 그 자체가 표현식입니다. 할당 따라서 값이 되므로 다른 변수에 다시 할당할 수 있습니다.

```javascript
let x,y;
y = x = 3*5;
```

x와 y 두 변수가 있고 값은 모두 15입니다. 곱셈과 할당이 모두 표현식이기 때문에 이런 일이 가능합니다. 자바스크립트는 이렇게 표현식이 결합된 것을 보면 쪼갤 수 있을 만큼 쪼개서 한 부분씩 실행합니다.

```javascript
let x, y
y = x = 3*5 //원래 문
y = x = 15 //곱셈 표현식을 평가했습니다.
y = 15 //첫 번째 할당을 평가했습니다. x는 이제 15이고, y는 아직 undefined입니다.
15; //두 번째 할당을 평가했습니다. y는 이제 15입니다.
	//전체 문의 결과는 15입니다. 
	//이 값은 사용하지도 않았고 어딘가에 할당하지도 않았으니 그냥 버려집니다.
```

자바스크립트가 표현식을 평가하는 순서를 연산자 우선수위라 부릅니다.

표현식은 대부분 연산자 표현식입니다. 즉 곱셈 표현식은 곱셈 연산자(*)와 피연산자(operand) 두 개로 이루어집니다. 피연산자는 서로 곱하는 두 숫자이며 피연산자 자체도 표현식입니다.

연산자 표현식이 아닌 표현식에는 식별자 표현식(변수와 상수 이름)과 리터럴 표현식 두 가지가 있습니다. 변수와 상수, 리터럴은 그 자체가 표현식입니다.

## 2. 연산자

표현식이 값이 되는 것이라면 연산자는 값을 만드는 행동이라는 뜻입니다.

### 산술 연산자

| 연산자   | 설명                            | 예제                                                    |
| -------- | ------------------------------- | ------------------------------------------------------- |
| ```-```  | 뺄셈                            | ```3+2 // 5```                                          |
| ```+```  | 덧셈(문자열 병합에도 쓰입니다.) | ```3-2 // 1```                                          |
| ```/```  | 나눗셈                          | ```3/2 // 1.5```                                        |
| ```*```  | 곱셈                            | ```3*2 // 6```                                          |
| ```%```  | 나머지                          | ```3%2 // 1```                                          |
| ```-```  | 단항 부정                       | ```-x // x의 부호를 바꿉니다.```                        |
| ```+```  | 단항 플러스                     | ```+x // x가 숫자가 아니면 숫자로 변환을 시도합니다.``` |
| ```++``` | 전위 증가                       | ```++x // x에 1을 더한 다음 평가합니다.```              |
| ```++``` | 후위 증가                       | ```x++ // x를 평가한 다음 1을 더합니다.```              |
| ```--``` | 전위 감소                       | ```- -x // x에서 1을 뺀 다음 평가합니다.```             |
| ```--``` | 후위 감소                       | ```x- - // x의 값을 평가한 다음 1을 뺍니다.```          |

### 비교 연산자

연산자는 일치함(equality, ```===```), 동등함(loose equality,``` ==```), 대소 관계의 세 타입으로 나뉩니다.

두 값이 같은 객체를 가리키거나, 같은 타입이고 값도 같다면(원시 타입) 이 값을 일치한다고 합니다. 한 편 두 값이 같은 객체를 가리키거나 같은 값을 갖도록 변환할 수 있다면 두 값을 동등하다고 합니다.

등등 연산자 때문에 문제가 생기는 경우는 대게 ```null```과 ```undefiend```, 빈 문자열, 숫자 0때문입니다. 위 네 가지 경우에 해당하지 않는 값을 비교한다면 동등 연산자를 써도 안전할 때가 많습니다. 하지만 기계적으로 동등 연산자를 쓰는 습관은 빨리 버릴 수록 좋습니다.

관계 연산자는 관계가 있는 값을 비교하며, 문자열이나 숫자처럼 원래 순서가 있는 데이터 타입에만 적용할 수 있습니다. 관계 연산자는 작다(```<```), 작거나 같다(```<=```), 크다(```>```), 크거나 같다(```>=```) 네 가지가 있습니다.

### 숫자 비교

특별한 숫자형 값 NaN은 그 자신을 포함하여 무엇과도 같지 않습니다. 즉, ```NaN === NaN```과 ```NaN == NaN```은 모두 ```false```입니다. 숫자가  ```NaN```인지 알아보려면 내장된 ```isNaN``` 함수를 사용해야 합니다. ```isNaN(x)```은 ```x```가 ```NaN```일 때 ```true```를 반환하고 그렇지 않다면 ```false```를 반환합니다.

### 문자열 병합

자바스크립트에서 ```+``` 연산자는 덧셈과 문자열 병합에 모두 사용됩니다. 피연산자의 타입을 보고 덧셈을 할지 문자열 병합을 할지 판단합니다. 덧셈과 병합은 모두 왼쪽에서 오른쪽으로 평가합니다. 자바스크립트는 두 피연산자를 모두 왼쪽에서 오른쪽으로 평가한 후, 피연산자 중 하나라도 문자열이면 문자열 병합을 수행합니다.

```javascript
3+5+"8" // "88"
"3"+5+8 // "358"
```

### 논리 연산자

#### 참 같은 값과 거짓 같은 값

자바스크립트에서는 모든 데이터 타입을 '참 같은 값(truthy)'과 '거짓 같은 값(falsy)'으로 나눌 수 있습니다. 자바스크립트에서 거짓 같은 값은 다음과 같습니다.

- ```undefiend```
- ```null```
- ```false```
- ```0```
- ```NaN```
- ```''```(빈 문자열)

이들 외에는 모두 참 같은 값입니다. 참 값은 값은 정말 많으므로 전부 나열할 수 없지만 몇 가지는 염두에 두어야 합니다.

- 모든 객체. ```valueOf()```를 호출했을 때 ```false```를 반환하는 객체도 참 같은 값에 속합니다.
- 배열. 빈 배열도 참 같은 값에 속합니다.
- 공백만 있는 문자열 (```'  '```등)
- 문자열 ```"false"```

### AND, OR, NOT

#### AND(&&) 연산의 진위표

| X     | Y     | X&&Y  |
| ----- | ----- | ----- |
| False | False | False |
| False | True  | False |
| True  | False | False |
| True  | True  | True  |

#### OR(||) 연산의 진위표

| X     | Y     | X\|\|Y |
| ----- | ----- | ------ |
| False | False | False  |
| False | True  | True   |
| True  | False | True   |
| True  | True  | True   |

#### NOT(!)의 진위표

| X     | !X    |
| ----- | ----- |
| False | True  |
| True  | False |

### 단축 평가

```AND``` 연산자의 진위표를 보면 두 값을 모두 평가하지 않아도 될 때가 있음을 알 수 있습니다. ```X```가 거짓 같은 값이면``` X&&Y```는 ```Y```의 값을 평가할 필요도 없이 ```true```입니다. 자바스크립트는 이런 방식으로 동작하며 이런 동작을 단축 평가(shor-circuit evaluation)라고 합니다.

#### 피연산자가 불리언이 아닐 때 논리 연산자가 동작하는 방법

불리언 피연산자를 사용하면 논리 연산자는 항상 불리언을 반환합니다. 피연산자가 불리언이 아니라면, 결과를 결정한 값이 반환됩니다.

##### 불리언이 아닌 피연산자에 대한 AND(&&)의 진위표

| X      | Y      | X&&Y |
| ------ | ------ | ---- |
| falsy  | falsy  | X    |
| falsy  | truthy | X    |
| truthy | falsy  | Y    |
| truthy | truthy | Y    |

##### 불리언이 아닌 피연산자에 대한 OR(||)의 진위표

| X      | Y      | X\|\|Y |
| ------ | ------ | ------ |
| falsy  | falsy  | Y      |
| falsy  | truthy | Y      |
| truthy | falsy  | X      |
| truthy | truthy | X      |

#### 조건 연산자

조건 연산자는 자바스크립트의 유일한 3항(ternary) 연산자입니다. 즉, 이 연산자는 피연산자 세개를 받습니다. 조건 연산자는 ```if...else```문과 동등한 표현식입니다.

```javascript
const doIt = false;
const result = doIt ? "Did it!" : "Didn't do it";
```

3항 연산자는 문이 아니라 표현식이므로 다른 표현식과 결합하여 매우 유용하게 사용할 수 있습니다.

#### 쉼표 연산자

쉼표 연산자는 표현식을 결합하여 두 표현식을 평가한 후, 두 번째 표현식의 결과를 반환합니다. 표현식을 하나 이상 실행해야 하지만 값으로 필요한 것은 마지막 표현식의 결과뿐일 때 쉼표 연산자를 유용하게 쓸 수 있습니다.

```javascript
let x = 0, y = 10, z;
z = (x++,y++);
```

### 연산자 그룹

그룹 연산자(괄호)에는 아무 효과도 없지만 연산자 우선순위를 높이거나 명확히 표현하는데 쓸 수 있습니다. 따라서 그룹 연산자는 연산 순서만 바꿀 뿐, 다른 부작용은 전혀 없는 안전한 연산자 입니다.

#### typeof 연산자

| 표현식              | 반환값      | 참고 |
| ------------------- | ----------- | ---- |
| typeof undefined    | "undefiend" |      |
| typeof null         | "object"    | ㅠㅜ |
| typeof {}           | "object"    |      |
| typeof []           | "object"    | ㅜㅠ |
| typeof true         | "boolean"   |      |
| typeof 1            | "number"    |      |
| typeof ""           | "string"    |      |
| typeof Symbol()     | "symbol"    |      |
| typeof function(){} | "Function"  |      |

#### 할당 연산자

| 연산자 | 동등한 표현 |
| ------ | ----------- |
| x+=y   | x = x+y     |
| y-=y   | y = x-y     |
| x*=y   | x = x*y     |
| x /=y  | x = x/y     |
| x %= y | x = x%y     |

### 해체 할당

이 기능은 객체나 배열을 변수로 '해체'할 수 있습니다

```javascript
//객체 선언
const obj = { b:2, c:3, d:4 }

//해체 할당
const { a, b, c } = obj;
a; //undefiend: obj에는 "a"프로퍼티가 없습니다.
b; //2
c; //3
d; //ReferenceError: "d"는 정의되지 않았습니다.

//배열 선언
const arr = [1,2,3];

//배열 해제 할당
let x,y = arr;
x; //1
y; //2
z; //ReferenceError:"z"는 정의되지 않았습니다.
```

Reference [Learning JavaScript](http://www.hanbit.co.kr/store/books/look.php?p_code=B2328850940)
