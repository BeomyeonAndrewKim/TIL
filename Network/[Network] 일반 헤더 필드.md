# HTTP 헤더

웹 사이트를 이용할 때 평소에는 볼 수가 없지만 HTTP 의 리퀘스트와 리스폰스에는 반드시 HTTP 헤더가 포함되어 있습니다.

#### 리퀘스트의 HTTP 메시지

* 메소드, URI, HTTP 버젼
  * 리퀘스트 라인
* HTTP 헤더 필드
  * 리퀘스트 헤더 필드
  * 일반 헤더 필드
  * 엔티티 헤더필드

#### 리스폰스의 HTTP 메시지

* HTTP 버젼, 상태 코드
  * 상태 라인
* HTTP 헤더 필드
  * 리스폰스 헤더 필드
  * 일반 헤더 필드
  * 엔티티 헤더 필드

## 1. HTTP 헤더 필드

### 1) HTTP 헤더 필드는 중요한 정보를 전달한다.

HTTP 헤더 필드는 HTTP 메시지를 구성하는 요소 중 하나입니다. 헤더 필드는 HTTP 프로토콜 중에서 클라이언트와 서버간의 통신에서 리퀘스트에도 리스폰스에도 사용되고 있고, 부가적으로 중요한 정보를 전달하는 역할을 담당하고 있습니다. 메시지 바디의 크기나 사용하고 있는 언어, 인증 정보 등을 브라우저나 서버에 제공하기 위해 사용되고 있습니다.

### 2) HTTP 헤더 필드의 구조

```http
Content-Type:text/html
헤더 필드 명: 필드 값
```

### 3) 4 종류의 HTTP 헤더 필드

* 일반적 헤더 필드(General Header FIelds)

리퀘스트 메시지와 리스폰스 메시지 둘 다 사용되는 헤더 입니다.

* 리퀘스트 헤더 필드(Request Header Fields)

클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더로 리퀘스트의 부가적 정보와 클라이언트의 정보, 리스폰스의 콘텐츠에 관한 우선 순위 등을 부가합니다.

* 리스폰스 헤더 필드(Response Header Fields)

서버 측에서 클라이언트 측으로 송신한 리스폰스 메시지에 사용되는 헤더로 리스폰스의 정보와 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가합니다.

* 엔티티 헤더 필드(Entity Header Fiedls)

리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더로 콘텐츠 갱신 시간 등의 엔티티에 관한 정보를 부가합니다.

## 2. HTTP/ 1.1 일반 헤더 필드

### 1) Cache-Control

디렉티브로 불리는 명령을 사용하여 캐싱 동작을 지정합니다. 지정한 디렉티브에는 파라미터가 있는 것과 없는 것도 있으며 여러 개의 디렉티브를 지정하는 경우에는 콤마 ","로 구분합니다. Cache-Control 헤더 필드의 디렉티브는 리퀘스트 및 리스폰스 할 때에 사용할 수 있습니다.

#### 캐시가 가능한지 여부를 나타내는 디렉티브

* **public**

```http
Cache-Control: public
```

다른 유저에게도 돌려줄 수 있는 캐시를 해도 좋다는 것을 명시적으로 나타냅니다.

* **private**

```http
Cache-Control: private
```

리스폰스는 특정 유저만을 대상으로하고 있다는 것을 나타냅니다. 캐시 서버는 특정 유저를 위해서 리소스를 캐시할 수 있지만, 다른 유저로부터 같은 리퀘스트가 온다고 하더라도 그 캐시를 반환하지 않도록 합니다.

* **no-cache**

```http
Cache-Control: no-cache
```

no-cache 디렉티브는 캐시로부터 오래된 리소스가 반환되는 것을 막기 위해 사용됩니다. 클라이언트의 리퀘스트로 no-cache 디렉티브로 사용된 경우, 캐시된 리스폰스를 클라이언트가 받아 들이지 않음을 나타냅니다. 즉, 중간 캐시 서버가 오리진 서버까지 리퀘스트를 전송해야합니다.

서버의 리스폰스에 no-cache 디렉티브가 사용된 경우, 캐시 서버는 리소스를 저장할 수 없습니다. 오리진 서버는 캐시 서버가 이후의 리퀘스트에서 리소스의 유효성을 재확인하지 않고는 그 리스폰스를 사용하지 못하도록 합니다.

```http
Cache-control: no-cache=Location
```

서버의 리스폰스로 no-cache 의 필드 값에 헤더 필드 명이 지정된 경우에는 이 지정된 헤더 필드만 캐시할 수 없습니다. 이 파라미터는 리스폰스 디렉티브만 사용할 수 있습니다.

#### 캐시로 보존 가능한 것을 제어하는 디렉티브

* no-store

```http
Cache-Control: no-store
```

리퀘스트(그와 대응되는 리스폰스) 혹은 리스폰스에 기밀 정보가 포함되어 있음을 나타냅니다.

#### 캐시 기한이나 검증을 지정하는 디렉티브

* s-maxage

```http
Cache-Control: s-maxage=604800(단위: 초)
```

기능은 max-age 디렉티브와 동일한데 다른 점은 여러 유저가 이용할 수 있는 공유 캐시 서버에만 적용된다는 것입니다. s-maxage 디렉티브가 있는 경우, Expires 헤더 필드와 max-age 디렉티브는 무시됩니다.

* max-age

```http
Cache-Control: max-age=604800(단위: 초)
```

클라이언트 리퀘스트로 사용되었다면 리소스가 최신 상태라고 판단할 최대 시간을 지정합니다. 서버의 리스스에서는 캐시 서버가 유효성의 재확인을 하지 않고 리소스를 캐시에 보존해 두는 최대 시간을 나타냅니다.

`Expires`에 반해, 이 디렉티브는 요청 시간과 관련이 있습니다. Expires 헤더가 필드가 달린 경우에는 max-age 디렉티브으 지정을 우선하고 Expires 헤더 필드는 무시합니다.

* Min-fresh

```http
Cache-Control: min-fresh=60(단위: 초)
```

캐시된 리소스가 적어도 지정된 시간은 최신 상태의 것을 반환하도록 캐시 서버에 요청합니다.

* max-stale

```http
Cache-Control: max-stale=3600(단위: 초)
```

캐시된 리소스의 유효 기한이 끝났더라도 받아들일 수 있음을 나타냅니다. 디렉티브에 값이 지정되어 있지 않는 경우는 클라이언트는 아무리 시간이 경과했더라도 리스폰스를 받아 들입니다. 값이 지정되어 있는 경우에는 유효 기한이 지난 후로부터 지정 시간 내라면 받아들인다는 뜻을 서버에 전달합니다. 초 단위의 값을 할당할 수 있는데, 이는 응답이 결코 만료되서는 안되는 시간을 나타냅니다.

* only-if-cached

```http
Cache-Control: only-if-cached
```

클라이언트는 캐시 서버에 대해서 목적한 리소스가 로컬 캐시에 있는 경우만 리스폰스를 반환하도록 요구합니다. 즉, 캐시 서버에서 리스폰스의 리로드와 유효성을 재확인하지 않도록 요구합니다. 캐시 서버가 로컬 캐시로부터 응답할 수 없는 경우에는 '504 Gateway Timeout' 상태를 반환합니다.

* must-revalidate

```http
Cache-Control: must-validate
```

리스폰스의 캐시가 현재도 유효한지 아닌지의 여부를 오리진 서버에 조회를 요구합니다. 프록시가 오리진 서버에 도달할 수 없고, 리소스를 다시 요구할 수 없는 경우에는 캐시는 클라이언트에 504(Gateway Timeout)를 반환합니다. 또한, must-revalidate 디렉티브가 사용되는 경우, 리퀘스트에서 max-stale 디렉티브를 사용하고 있더라도 무시합니다.

* proxy-revalidate

```http
Cache-Control: proxy-validate
```

모든 캐시 서버에 대해서 이후의 리퀘스트로 해당 리스폰스를 반환할 때는 반드시 유효성 재확인을 하도록 요구합니다.

* no-transfrom

```http
Cache-Control: no-transform
```

리퀘스트와 리스폰스의 어느 쪽에 있어서도 캐시가 엔티티 바디의 미디어 타입을 변경하지 않도록 지정합니다. 캐시 서버 등에 의해서 이미지가 압축되는 것은 방지합니다.

#### Cache-Control 확장

* Cache-extension 토큰

```http
Cache-Control: private, community="UCI"
```

community 라는 디렉티브는 Cache-Control 헤더 필드에는 없지만 extension tokens 에 의해서 추가할 수 있습니다. 만약 캐시 서버가 새로운 디렉티브 "community"를 이해하지 못할 경우에는 무시합니다.

### 2) Connection

#### 프록시에 더 이상 전송하지 않는 헤더 필드를 지정

```http
Connection: 더 이상 전송하지 않는 헤더 필드 명
```

Connection 헤더 필드를 사용하여 프록시 서버에 더 이상 전송하지 않는 헤더 필드(hop-by-hop 헤더)를 지정할 수 있습니다.

#### 지속적 접속 관리

```http
Connection: close
```

HTTP/1.1 에서는 지속적 접속이 디폴트로 되어 있습니다. 그래서 리퀘스트를 송신했던 클라이언트는 접속이 계속 유지되면서 추가 리퀘스트를 송신하도록 합니다. 서버 측에서 명시적으로 접속을 끊고 싶을 경우에는 Connection 헤더 필드에 Close 라고 지정합니다.

HTTP/ 1.1 버젼 이하에서는 Keep-alive 로 지정해야 지속적 접속이 가능합니다.

### 3) Date

```http
Date: Tue, 03 Jul 2012 04:40:59 GMT
```

HTTP 메시지를 생성한 날짜를 나타냅니다.

### 4) Trailer

메시지 바디의 뒤에 기술되어 있는 헤더 필드를 미리 전달할 수 있습니다. HTTP/1.1 에 구현되어 있는 청크 전송 인코딩을 사용하고 있는 경우에 사용 가능합니다.

```http
HTTP/1.1 200 OK
Date: Tue, 03 Jul 2012 04:40:59 GMT
Content-Type: text/html
...
Transfer-Encoding: chunked
Trailer: Expires

..(메시지 바디)...
0
Expires: Tue, 03 Jul 2015 04:40:59 GMT
```

### 5) Transfer-Encoding

메시지 바디의 전송 코딩 형식을 지정하는 경우에 사용됩니다. HTTP/1.1 에서 전송 코딩 형식으로 청크 전송만이 정의되어 있습니다.

### 6) Upgrade

HTTP 및 다른 프로토콜의 새로운 버전이 통신에 이용되는 경우에 사용됩니다. 지정하는 대상이 전혀 다른 통신 프로토콜이라고 하더라도 문제 없습니다.

Upgrade 헤더 필드가 달린 리퀘스트에 대해서 서버는 상태 코드 101 Switching Protocols 라는 리스폰스로 응답할 수 있습니다.

### 7) Via

클라이언트와 서버 간의 리퀘스트 혹은 리스폰스 메시지의 경로를 알기 위해서 사용됩니다. 프록시 혹은 게이트웨이는 자신의 Via 헤더 필드에 추가한 뒤 메시지를 전송합니다. Via 헤더 필드는 전송된 메시지의 추적과 리퀘스트 루프의 회피 등에 사용되기 때문에 프록시를 경유하는 경우에는 반드시 부가할 필요가 있습니다.

Via 헤더는 배송 경로를 알기 위해서 TRACE 메소드와 연계해서 자주 사용됩니다.

### 8) Warning

```http
Warning: [경고 코드][경고한 호스트:포트 번호]"[경고문]"([날짜])
```

| 코드 | 경고문                           | 설명                                                                                              |
| ---- | -------------------------------- | ------------------------------------------------------------------------------------------------- |
| 110  | Response is state                | 프록시가 유효기한이 지난 리소스를 반환했다.                                                       |
| 111  | Revalidation failed              | 프록시가 리소스의 유효성 재확인에 실패했다.                                                       |
| 112  | Disconnection Operation          | 프록시가 네트워크로부터 고의로 끊겨 있다.                                                         |
| 113  | Heuristic expiration             | 리스폰스가 24 시간 이상 경과하고 있는 경우(캐시의 유효기한을 24 시간 이상으로 설정하고 있는 경우) |
| 199  | Miscellaneous warning            | 임의의 경고문                                                                                     |
| 214  | Transformation applied           | 프록시가 인코딩 미디어 타입등에 대응해서 무언가의 처리를 한 경우                                  |
| 299  | Miscellaneous persistent warning | 임의의 경고문                                                                                     |

Reference [그림으로 배우는 HTTP & Network Basic](http://www.youngjin.com/book/book_detail.asp?prod_cd=9788931447897&seq=5470&cate_cd=1&child_cate_cd=10&goPage=1&orderByCd=1&searchType=Y&keyword1=%B1%D7%B8%B2%C0%B8%B7%CE%20%B9%E8%BF%EC%B4%C2%20http)
