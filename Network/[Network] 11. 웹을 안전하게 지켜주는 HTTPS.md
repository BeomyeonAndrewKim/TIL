# 웹을 안전하게 지켜주는 HTTPS

## 1. HTTP 의 약점

- 평문(암호화 하지 않은) 통신이기 때문에 도청 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능

다른 암호화하지 않은 프로토콜에도 공통되는 문제입니다. 특정 웹서버나 특정 웹 클라리언트의 구현상의 약점, Java나 PHP등으로 구축한 웹 에플리케이션 취약점 등이 있습니다.

### 1) 평문이기 때문에 도청 가능

#### - TCP/IP는 도청 가능한 네트워크

TCP/IP 구조의 통신 내용은 전부 통신 경로의 도중에 엿볼 수 있습니다. 네트워크 상을 흐르고 있는 패킷을 수집하는 것만으로 도청할 수 있게 됩니다. 패킷을 수집하려면 패킷을 해석하는 패킷 캡처나 스니퍼라는 툴을 사용합니다.

#### - 암호화로 도청을 피하다

##### 통신 암호화

SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)이라는 다른 프로토콜을 조합함으로써 HTTPS의 통신 내용을 암호화 할 수 있습니다. SSL등을 이용해 안전한 통신로를 확립하고 나서 그 통신로를 사용해 HTTP 통신을 합니다. SSL을 조합한 HTTP를 HTTPS(HTTP Secure)나 HTTP over SSL이라 불리고 있습니다.

#####  콘텐츠 암호화

콘텐츠의 내용 자체를 암호화해 버리는 방법이 있습니다. 이 경우 클라이언트에서 HTTP 메시지를 암호화해서 출력하는 처리가 필요하게 됩니다. 

물론 콘텐츠의 암호화를 유효하게 하기 위해서는 클라이언트와 서버가 콘텐츠의 암호화나 복호화 구조를 가지고 있는 것이 전제가 되므로, 평상시에 유저가 사용하는 브라우저와 웹 서버에서는 이용하는 것은 어렵습니다. 주로 웹서비스 등에서 이용되는 방법입니다.

### 2) 통신 상대를 확인하지 않기 때문에 위장 가능

HTTP를 사용한 리퀘스트나 리스폰스에서는 통신 상대를 확인하지 않습니다. 리퀘스트를 보낸 서버가 정말로 URI에서 지정된 호스트인지 아닌지, 리스폰스를 반환한 클라이언트가 정말로 리퀘스트를 출력한 클라이언트인지 아닌지를 모른다는 것입니다. 

#### - 누구나 리퀘스트 할 수 있다

HTTP는 누구이던 간에 리퀘스트를 보내면 리스폰스가 반환되는 매우 심플한 구조로 되어 있지만, 상대를 확인하지 않는 점이 약점일 수가 있습니다.

- 리퀘스트를 보낸 곳의 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지 아닌지를 확인할 수 없다. 위장한 웹 서버일 우려가 있다.
- 리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지 아닌지를 확인할 수 없다. 위장한 클라이언트일 우려가 있다.
- 통신하고 있는 상대가 접근이 허가된 상대인지 아닌지를 확인할 수 없다. 중요한 정보를 가진 웹서버에서는 특정 상대만 통신을 허가하고 싶을 때가 있다.
- 어디의 누가 리퀘스트를 했는지를 확인할 수 없다.
- 의미없는 리퀘스트라도 수신하게 된다. 대량의 리퀘스트에 의한 DoS(서비스 불능 공격) 공격을 방지할 수 없다.

#### - 상대를 확인하는 증명서

HTTP에서는 통신 상대를 확인할 수 없지만 SSL로 상대를 확인할 수 있습니다. SSL은 암호화뿐만 아니라 상대를 확인하는 수단으로 증명서를 제공하고 있습니다. 

증명서는 신뢰할 수 있는 제3자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명합니다. 또 그 증명서를 위조하는 것은 기술적으로 상당히 어렵습니다. 통신 상대의 서버나 클라이언트가 가진 증명서를 확인함으로써 통신 상대가 내가 통신하고자 하는 상대인지 아닌지를 판단할 수 있습니다.

이 증명서를 이용함으로써, 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 됩니다. 또한 클라이언트가 증명서를 가짐으로써 보인 확인을 하고, 웹 사이트 인증에서 이용할 수도 있습니다.

### 3) 완전성을 증명할 수 없기 때문에 변조 가능

완전성이란 정보의 정확성을 가리킵니다. 그것을 증명할 수 없다는 것은 정보가 정확한지 아닌지를 확인할 수 없음을 의미합니다.

#### - 수신한 내용이 다를지도 모른다

만약 리퀘스트나 리스폰스가 발신된 후에 상대가 수신할 때까지의 사이에 변조되었다 하더라도 이 사실을 알 수 없습니다. 즉, 발신된 리퀘스트나 리스폰스와 수신한 리퀘스트나 리스폰스가 같은지 아닌지를 확인할 수 없다는 의미입니다. 

공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자 공격(Man-in-the-Middle 공격)이라고 부릅니다.

#### - 변조를 방지하려면?

MD5나 SHA-1 등의 해시 값을 확인하는 방법과 디지털 서명을 확인하는 방법등을 사용해 변조를 방지할 수 있습니다. 

파일 다우느로드 서비스를 제공하고 있는 웹 사이트에서는 PGP(Pretty Good Privacy)에 의한 서명과 MD5에 의한 해시 값을 제공하는 일이 있습니다. RGP는 파일을 작성했다는 증명을 위한 서명으로, MD5는 단방향성 함수에 의한 해시 값입니다. 어느 쪽을 사용하더라도 클라이언트를 이용하고 있는 유저 자신이 다운로드 받은 파일을 토대로 검사할 필요가 있습니다. 브라우저에서 자동적으로 검사가 진행되는 것은 아닙니다.

그러나 아쉽게도 이 방법으로 확실히 확인할 수 있는 것은 아닙니다. 그것은 PGP와 MD5 자체도 적절하게 수정되어 있다고 한다면, 유저로서는 알 수가 없습니다. 확실히 방지하기에는 HTTPS를 사용할 필요가 있습니다. SSL에는 인증이나 암호화, 그리고 다이제스트 기능을 제공하고 있습니다. HTTP만으로는 완전성을 보증하는 거싱 어렵기 때문에 다른 프로토콜을 조합함으로써 실현하고 있습니다.

## 2. HTTP+암호화+인증+ 완전성 보호= HTTPS

### 1) HTTP에 암호화와 인증과 완전성 보호를 더한 HTTPS

HTTP에 암호화나 인증 등의 구조를 더한 것을 HTTPS(HTTP Secure)라고 부릅니다.

HTTPS를 사용하는 통신은 웹 페이지의 로그인이나 쇼핑의 결제 화면 등에서 사용되고 있습니다. HTTPS를 사용한 통신은 http:// 가 아닌 https:// 를 사용합니다. 또한, 브라우저에서 HTTPS가 유효한 웹 사이트에 액세스하면 자물쇠 마크가 표시됩니다.

### 2) HTTPS는 SSL의 껍질을 덮어쓴 HTTP

HTTPS는 새로운 애플리케이션 계층의 프로토콜은 아닙니다. HTTP 통신을 하는 소켓 부분을 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)이라는 프로토콜로 대체하고 있을 뿐입니다.

보통 HTTP는 직접 TCP와 통신하지만 SSL을 사용한 경우에는 HTTP는 SSL과 통신하고 SSL이 TCP와 통신하게 됩니다.

SSL을 사용함으로써 HTTP는 HTTPS로서 암호화와 증명서와 완전성 보호를 이용할 수 있게 됩니다.

### 3) 상호간에 키를 교환하는 공개키 암호화 방식

SSL에서는 공개키 암호화 방식이라는 암호화 방식을 채용하고 있습니다. 현대의 암호는 알고리즘이 공개되어 있고 키를 비밀에 부침으로 안정성을 유지합니다. 암호화나 복호화할 때 이 키를 사용합니다. 키가 없으면 암호를 풀 수 없지만 반대로 생각해보면 키를 가지고 있다면 누구라도 암호를 풀 수 있습니다. 공격자가 키를 알게 되면 암호화가 의미를 잃어버리게 됩니다.

#### - 공통키 암호의 딜레마

암호화와 복호화에 하나의 키를 사용하는 방식을 공통키 암호라고 부릅니다. 공통키 암호화 방식은 상대방에게 키를 넘겨주지 않으면 안됩니다. 네트워크를 사용해서 키를 넘겨줄 때 통신이 도청되어 공격자에게 키를 뺴앗기게 되면 암호화의 의미가 없게 되어 버립니다.

#### - 두 개의 키를 사용하는 공개키 암호

공개키 암호에서는 서로 다른 두 개의 키 페어를 사용합니다. 한쪽은 비밀키(private key)라 부르고 다른 한쪽은 공개키(public key)라고 부릅니다. 

공개키 암호를 사용한 암호화는 암호를 보내는 측이 상대의 공개키를 사용해 암호화를 합니다. 그리고 암호화된 정보를 받아들인 상대는 자신의 비밀키를 사용해 복호화를 실시합니다. 이 방식은 암호를 푸는 비밀키를 통신으로 보낼 필요가 없기 때문에 도청에 의해서 키를 빼앗길 걱정은 없습니다. 

또 암호문과 공개키라는 정보에서 평문을 구하는 것은 매우 어려운 수학적인 특징이 있기 때문에 간단하지는 않습니다.

#### - HTTPS는 하이브리드 암호 시스템

HTTPS는 공통키 암호와 공개키 암호의 양쪽 성질을 가진 하이브리드 암호 시스템 입니다. 키를 안전하게 교환할 수 있다면 공개키 암호만을 사용해서 통신을 해도 괜찮다고 생각할 지도 모르지만, 공개키 암호는 공통키 암호에 비해서 처리 속도가 늦습니다. 

두 가지 장점을 살릴 수 있도록 각각의 방식을 조합해서 통신합니다. 키를 교환하는 곳에서는 공개키 암호를 사용하고 그 후의 통신에서 메시지를 교환하는 곳에서 공통키 암호를 사용합니다.

### 4) 공개키가 정확한지 아닌지를 증명하는 증명서

공개키의 문제점은 공개키가 진짜인지 아닌지를 증명할 수 없다는 것입니다.  예를 들면, 어떤 서버와 공개키 암호를 사용해서 통신을 시작하려 할 때 수신한 공개키가 본래 의도한 서버가 발행한 공개키인지를 어떻게 증명할 수 있을까요? 도중에 공격자가 공개키를 바꿔치기 했을지도 모릅니다.

이 문제를 해결하는 데는 인증 기관(CA: Certificate Authority)과 그 기관이 발행하는 공개키 증명서가 이용되고 있습니다. 인증 기관이란 클라이언트와 서버가 모두 신뢰하는 제 3자 기관입니다. 

인증 기관은 다음과 같이 이용됩니다. 먼저 서버의 운영자가 인증 기관에 공개 키를 제출합니다. 인증 기관은 제출된 공개키에 디지털 서명을 하고 서명이 끝난 공개키를 만듭니다. 그리고 공개키 인증서에 서명이 끝난 공개키를 담습니다.

서버는 이 인증 기관에 의해서 작성된 공개키 인증서를 클라이언트에 보내고 공개키 암호로 통신합니다. 공개키 인증서는 디지털 증명서나 줄여서 증명서라고 부르는 경우도 있습니다. 증명서를 받은 클라이언트는 증명 기관의 공개키를 사용해서 서버의 공개키를 인증한 것이 진짜 인증 기관이라는 것과 서버의 공개키가 신뢰할 수 있다는 것을 알 수 있습니다.

여기에서 사용되는 인증 기관의 공개키는 안전하게 클라이언트에 전달되어야 합니다. 통신중에는 어떤 방법을 사용하더라도 안전하게 전달하는 것은 어렵기 때문에 많은 브라우저가 주요 인증 기관의 공개키를 사전에 내장한 상태로 제품을 내놓고 있습니다.

#### - 조직의 실제성을 증명하는 EV SSL 증명서

증명서의 역할은 서버가 올바른 통신 상대임을 증명하는 것이지만, 상대방이 실제로 있는 기업인지 확인하는 역할도 있습니다. 그러한 역할을 가진 증명서를 EV SSL 증명서라고 합니다.

EV SSL 증명서는 세계 표준의 인정 가이드라인에 의해서 발행되는 증명서입니다. 운영하는 조직의 실재성을 확인하는 방법을 엄격히 규정하고 있기 때문에 웹 사이트의 신뢰성을 더욱 높일 수 있습니다.

브라우저의 주소창의 색이 녹색으로 변하면 EV SSL 증명서로 증명된 웹 사이트인 것을 시각적으로 알 수 있습니다. 그리고 주소창 옆에는 SSL 증명서에 기재되어 있는 조직명 및 증명서를 발행한 인증 기관 명이 표시됩니다.

#### - 클라리언트를 확인하는 클라이언트 증명서

클라이언트 증명서를 이용하여 서버 증명서와 같이 서버가 통신하고 있는 상대가 의도한 클라이언트인 것을 증명하는 클라이언트 인증을 할 수 있습니다.

클라이언트 증명서는 몇 가지 문제점이 있습니다. 먼저, 클라이언트 증명서에서 문제가 되는 점은 증명서의 입수와 배포입니다. 유저가 클라이언트 증명서를 인스톨할 필요가 있습니다. 클라이언트 증명서는 유료로 구입할 필요가 있기 때문에 유저 수만큼 비용이 들게 됩니다.

안전성이 매우 높은 인증 기능을 제공할 수 있지만 특정 용도로만 사용되는 실정입니다. 

### 5) 안전한 통신을 하는 HTTPS 구조

- 클라이언트가 Client Hello 메시지를 송신하면 SSL 통신을 시작합니다. 메시지에는 클라이언트가 제공하는 SSL 버전을 지정하고, 암호 스위트(Cipher Suite)로 불리는 리스트(사용하는 암호화의 알고리즘이나 키 사이즈 등) 등이 포함되어 있습니다.
- 서버가 SSL 통신이 가능한 경우에는 Server Hello 메시지로 응답합니다. 클라이언트와 같이 SSL 버전과 암호 스위트를 포함합니다. 서버의 암호 스위트 내용은 클라이언트에서 받은 암호 스위트의 내용에서 선택된 것입니다.
- 서버가 Certificate 메시지를 송신합니다. 메시지에는 공개키 증명서가 포함되어 있습니다.
- 서버가 Server Hello Done 메시지를 송신하여 최초의 SSL 네고시에이션 부분이 끝났음을 통지합니다.
- SSL의 최초 네고시에이션이 종료되면 클라이언트가 Client Ket Exchange 메시지로 응답합니다. 메시지에는 통신을 암호화하는데 사용하는 Pre-Master secret이 포함되어 있습니다.  
- 클라이언트는 Change Cipher Spec 메시지를 송신합니다. 이 메시지는 이후의 통신은 암호키를 사용해서 진행한다는 것을 나타내고 있습니다.
- 클라이언트는 Finished 메시지를 송신합니다. 이 메시지는 접속 전체의 체크 값을 포함하고 있습니다. 네고시에이션이 성공했는지 어떤지는 서버가 이 메시지를 올바르게 복호화 할 수 있는지 아닌지가 결정됩니다. 
- 서버에서도 마찬가지로 Change Cipher Spec 메시지를 송신합니다.
- 서버에서도 마찬가지로 Finished 메시지를 송신합니다.
- 서버와 클라이언트의 Finished 메시지 교환이 완료되면 SSL에 의해서 접속은 확립됩니다. 물론 통신은 SSL에 의해서 보호되고 있습니다. 이제부터는 애플리케이션 계층의 프로토콜에 의해 통신을 합니다. 즉, HTTP 리퀘스트를 송신합니다.
- 애플리케션 계층의 프로토콜에 의한 통신입니다. 즉, HTTP 리스폰스를 송신합니다.
- 마지막에 클라이언트가 접속을 끊습니다. 접속을 끊을 경우에는 close_notify 메시지를 송신합니다. 그림에서는 생략되었지만, 그 후에 TCP FIN 메시지를 보내 TCP 통신을 종료합니다.

이 흐름에 더해서, 애플리케이션 계층의 데이터를 송신할 때에는 MAC(Message Authentication Code)이라고 불리우는 메시지 다이제스트를 덧붙일 수도 있습니다. MAC를 이용해서 변조를 감지할 수 있어서 완전성 보호를 실현할 수 있습니다.

#### - SSL은 느리다?

SSL 통신이 지연되는 이유에는 두 가지가 있습니다. 하나는 통신속도가 떨어지는 거소가, 다른 하나는 CPU나 메모리 등의 리소스를 다량으로 소비함으로써 처리가 느려지는 것입니다.

느려지는 것에 대한 근본적인 해결 방법은 없기 때문에, SSL 엑셀레이터라는 하드웨어(appliance 서버)를 사용해서 이 문제를 해결하기도 합니다. SSL 액셀레이터는 SSL을 처리하기 위한 전용 하드웨어로 SSL을 처리할 때보다 몇 배 빠른 계산을 할 수 있습니다. SSL의 처리만 SSL 엑셀레이터에 맡김으로써 부하를 분산하도록 하고 있습니다.